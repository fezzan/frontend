{"ast":null,"code":"class Utils {\n  /**\n   * Get first character from first & last sentences of a username\n   * @param {String} name - Username\n   * @return {String} 2 characters string\n   */\n  static getNameInitial(name) {\n    let initials = name.match(/\\b\\w/g) || [];\n    return ((initials.shift() || '') + (initials.pop() || '')).toUpperCase();\n  }\n  /**\n   * Get current path related object from Navigation Tree\n   * @param {Array} navTree - Navigation Tree from directory 'configs/NavigationConfig'\n   * @param {String} path - Location path you looking for e.g '/app/dashboards/analytic'\n   * @return {Object} object that contained the path string\n   */\n\n\n  static getRouteInfo(navTree, path) {\n    if (navTree.path === path) {\n      return navTree;\n    }\n\n    let route;\n\n    for (let p in navTree) {\n      if (navTree.hasOwnProperty(p) && typeof navTree[p] === 'object') {\n        route = this.getRouteInfo(navTree[p], path);\n\n        if (route) {\n          return route;\n        }\n      }\n    }\n\n    return route;\n  }\n  /**\n   * Get accessible color contrast\n   * @param {String} hex - Hex color code e.g '#3e82f7'\n   * @return {String} 'dark' or 'light'\n   */\n\n\n  static getColorContrast(hex) {\n    if (!hex) {\n      return 'dark';\n    }\n\n    const threshold = 130;\n    const hRed = hexToR(hex);\n    const hGreen = hexToG(hex);\n    const hBlue = hexToB(hex);\n\n    function hexToR(h) {\n      return parseInt(cutHex(h).substring(0, 2), 16);\n    }\n\n    function hexToG(h) {\n      return parseInt(cutHex(h).substring(2, 4), 16);\n    }\n\n    function hexToB(h) {\n      return parseInt(cutHex(h).substring(4, 6), 16);\n    }\n\n    function cutHex(h) {\n      return h.charAt(0) === '#' ? h.substring(1, 7) : h;\n    }\n\n    const cBrightness = (hRed * 299 + hGreen * 587 + hBlue * 114) / 1000;\n\n    if (cBrightness > threshold) {\n      return 'dark';\n    } else {\n      return 'light';\n    }\n  }\n  /**\n   * Darken or lighten a hex color \n   * @param {String} color - Hex color code e.g '#3e82f7'\n   * @param {Number} percent - Percentage -100 to 100, positive for lighten, negative for darken\n   * @return {String} Darken or lighten color \n   */\n\n\n  static shadeColor(color, percent) {\n    let R = parseInt(color.substring(1, 3), 16);\n    let G = parseInt(color.substring(3, 5), 16);\n    let B = parseInt(color.substring(5, 7), 16);\n    R = parseInt(R * (100 + percent) / 100);\n    G = parseInt(G * (100 + percent) / 100);\n    B = parseInt(B * (100 + percent) / 100);\n    R = R < 255 ? R : 255;\n    G = G < 255 ? G : 255;\n    B = B < 255 ? B : 255;\n    const RR = R.toString(16).length === 1 ? `0${R.toString(16)}` : R.toString(16);\n    const GG = G.toString(16).length === 1 ? `0${G.toString(16)}` : G.toString(16);\n    const BB = B.toString(16).length === 1 ? `0${B.toString(16)}` : B.toString(16);\n    return `#${RR}${GG}${BB}`;\n  }\n  /**\n   * Convert RGBA to HEX \n   * @param {String} rgba - RGBA color code e.g 'rgba(197, 200, 198, .2)')'\n   * @return {String} HEX color \n   */\n\n\n  static rgbaToHex(rgba) {\n    const trim = str => str.replace(/^\\s+|\\s+$/gm, '');\n\n    const inParts = rgba.substring(rgba.indexOf(\"(\")).split(\",\"),\n          r = parseInt(trim(inParts[0].substring(1)), 10),\n          g = parseInt(trim(inParts[1]), 10),\n          b = parseInt(trim(inParts[2]), 10),\n          a = parseFloat(trim(inParts[3].substring(0, inParts[3].length - 1))).toFixed(2);\n    const outParts = [r.toString(16), g.toString(16), b.toString(16), Math.round(a * 255).toString(16).substring(0, 2)];\n    outParts.forEach(function (part, i) {\n      if (part.length === 1) {\n        outParts[i] = '0' + part;\n      }\n    });\n    return `#${outParts.join('')}`;\n  }\n  /**\n   * Returns either a positive or negative \n   * @param {Number} number - number value\n   * @param {any} positive - value that return when positive\n   * @param {any} negative - value that return when negative\n   * @return {any} positive or negative value based on param\n   */\n\n\n  static getSignNum(number, positive, negative) {\n    if (number > 0) {\n      return positive;\n    }\n\n    if (number < 0) {\n      return negative;\n    }\n\n    return null;\n  }\n  /**\n   * Returns either ascending or descending value\n   * @param {Object} a - antd Table sorter param a\n   * @param {Object} b - antd Table sorter param b\n   * @param {String} key - object key for compare\n   * @return {any} a value minus b value\n   */\n\n\n  static antdTableSorter(a, b, key) {\n    if (typeof a[key] === 'number' && typeof b[key] === 'number') {\n      return a[key] - b[key];\n    }\n\n    if (typeof a[key] === 'string' && typeof b[key] === 'string') {\n      a = a[key].toLowerCase();\n      b = b[key].toLowerCase();\n      return a > b ? -1 : b > a ? 1 : 0;\n    }\n\n    return;\n  }\n  /**\n   * Filter array of object \n   * @param {Array} list - array of objects that need to filter\n   * @param {String} key - object key target\n   * @param {any} value  - value that excluded from filter\n   * @return {Array} a value minus b value\n   */\n\n\n  static filterArray(list, key, value) {\n    let data = list;\n\n    if (list) {\n      data = list.filter(item => item[key] === value);\n    }\n\n    return data;\n  }\n  /**\n   * Remove object from array by value\n   * @param {Array} list - array of objects\n   * @param {String} key - object key target\n   * @param {any} value  - target value\n   * @return {Array} Array that removed target object\n   */\n\n\n  static deleteArrayRow(list, key, value) {\n    let data = list;\n\n    if (list) {\n      data = list.filter(item => item[key] !== value);\n    }\n\n    return data;\n  }\n  /**\n   * Wild card search on all property of the object\n   * @param {Number | String} input - any value to search\n   * @param {Array} list - array for search\n   * @return {Array} array of object contained keyword\n   */\n\n\n  static wildCardSearch(list, input) {\n    const searchText = item => {\n      for (let key in item) {\n        if (item[key] == null) {\n          continue;\n        }\n\n        if (item[key].toString().toUpperCase().indexOf(input.toString().toUpperCase()) !== -1) {\n          return true;\n        }\n      }\n    };\n\n    list = list.filter(value => searchText(value));\n    return list;\n  }\n  /**\n   * Get Breakpoint\n   * @param {Object} screens - Grid.useBreakpoint() from antd\n   * @return {Array} array of breakpoint size\n   */\n\n\n  static getBreakPoint(screens) {\n    let breakpoints = [];\n\n    for (const key in screens) {\n      if (screens.hasOwnProperty(key)) {\n        const element = screens[key];\n\n        if (element) {\n          breakpoints.push(key);\n        }\n      }\n    }\n\n    return breakpoints;\n  }\n\n}\n\nexport default Utils;","map":{"version":3,"sources":["/Users/talhafiaz/Projects/React/Controrg/src/utils/index.js"],"names":["Utils","getNameInitial","name","initials","match","shift","pop","toUpperCase","getRouteInfo","navTree","path","route","p","hasOwnProperty","getColorContrast","hex","threshold","hRed","hexToR","hGreen","hexToG","hBlue","hexToB","h","parseInt","cutHex","substring","charAt","cBrightness","shadeColor","color","percent","R","G","B","RR","toString","length","GG","BB","rgbaToHex","rgba","trim","str","replace","inParts","indexOf","split","r","g","b","a","parseFloat","toFixed","outParts","Math","round","forEach","part","i","join","getSignNum","number","positive","negative","antdTableSorter","key","toLowerCase","filterArray","list","value","data","filter","item","deleteArrayRow","wildCardSearch","input","searchText","getBreakPoint","screens","breakpoints","element","push"],"mappings":"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","sourcesContent":["class Utils {\n\n\t/**\n\t * Get first character from first & last sentences of a username\n\t * @param {String} name - Username\n\t * @return {String} 2 characters string\n\t */\n\tstatic getNameInitial(name) {\n\t\tlet initials = name.match(/\\b\\w/g) || [];\n\t\treturn ((initials.shift() || '') + (initials.pop() || '')).toUpperCase();\n\t}\n\n\t/**\n\t * Get current path related object from Navigation Tree\n\t * @param {Array} navTree - Navigation Tree from directory 'configs/NavigationConfig'\n\t * @param {String} path - Location path you looking for e.g '/app/dashboards/analytic'\n\t * @return {Object} object that contained the path string\n\t */\n\tstatic getRouteInfo(navTree, path) {\n\t\tif( navTree.path === path ){\n\t\t  return navTree;\n\t\t}\n\t\tlet route; \n\t\tfor (let p in navTree) {\n\t\t  if( navTree.hasOwnProperty(p) && typeof navTree[p] === 'object' ) {\n\t\t\t\troute = this.getRouteInfo(navTree[p], path);\n\t\t\t\tif(route){\n\t\t\t\t\treturn route;\n\t\t\t\t}\n\t\t  }\n\t\t}\n\t\treturn route;\n\t}\t\n\n\t/**\n\t * Get accessible color contrast\n\t * @param {String} hex - Hex color code e.g '#3e82f7'\n\t * @return {String} 'dark' or 'light'\n\t */\n\tstatic getColorContrast(hex){\n\t\tif(!hex) {\n\t\t\treturn 'dark'\n\t\t}\n\t\tconst threshold = 130;\n\t\tconst hRed = hexToR(hex);\n\t\tconst hGreen = hexToG(hex);\n\t\tconst hBlue = hexToB(hex);\n\t\tfunction hexToR(h) {return parseInt((cutHex(h)).substring(0,2),16)}\n\t\tfunction hexToG(h) {return parseInt((cutHex(h)).substring(2,4),16)}\n\t\tfunction hexToB(h) {return parseInt((cutHex(h)).substring(4,6),16)}\n\t\tfunction cutHex(h) {return (h.charAt(0) === '#') ? h.substring(1,7):h}\n\t\tconst cBrightness = ((hRed * 299) + (hGreen * 587) + (hBlue * 114)) / 1000;\n\t\tif (cBrightness > threshold){\n\t\t\treturn 'dark'\n\t\t} else { \n\t\t\treturn 'light'\n\t\t}\t\n\t}\n\n\t/**\n\t * Darken or lighten a hex color \n\t * @param {String} color - Hex color code e.g '#3e82f7'\n\t * @param {Number} percent - Percentage -100 to 100, positive for lighten, negative for darken\n\t * @return {String} Darken or lighten color \n\t */\n\tstatic shadeColor(color, percent) {\n\t\tlet R = parseInt(color.substring(1,3),16);\n\t\tlet G = parseInt(color.substring(3,5),16);\n\t\tlet B = parseInt(color.substring(5,7),16);\n\t\tR = parseInt(R * (100 + percent) / 100);\n\t\tG = parseInt(G * (100 + percent) / 100);\n\t\tB = parseInt(B * (100 + percent) / 100);\n\t\tR = (R<255)?R:255;  \n\t\tG = (G<255)?G:255;  \n\t\tB = (B<255)?B:255;  \n\t\tconst RR = ((R.toString(16).length === 1) ? `0${R.toString(16)}` : R.toString(16));\n\t\tconst GG = ((G.toString(16).length === 1) ? `0${G.toString(16)}` : G.toString(16));\n\t\tconst BB = ((B.toString(16).length === 1) ? `0${B.toString(16)}` : B.toString(16));\n\t\treturn `#${RR}${GG}${BB}`; \n\t}\n\n\t/**\n\t * Convert RGBA to HEX \n\t * @param {String} rgba - RGBA color code e.g 'rgba(197, 200, 198, .2)')'\n\t * @return {String} HEX color \n\t */\n\tstatic rgbaToHex(rgba) {\n\t\tconst trim = str => (str.replace(/^\\s+|\\s+$/gm,''))\n\t\tconst inParts = rgba.substring(rgba.indexOf(\"(\")).split(\",\"),\n\t\t\tr = parseInt(trim(inParts[0].substring(1)), 10),\n\t\t\tg = parseInt(trim(inParts[1]), 10),\n\t\t\tb = parseInt(trim(inParts[2]), 10),\n\t\t\ta = parseFloat(trim(inParts[3].substring(0, inParts[3].length - 1))).toFixed(2);\n\t\t\tconst outParts = [\n\t\t\tr.toString(16),\n\t\t\tg.toString(16),\n\t\t\tb.toString(16),\n\t\t\tMath.round(a * 255).toString(16).substring(0, 2)\n\t\t];\n\n\t\toutParts.forEach(function (part, i) {\n\t\t\tif (part.length === 1) {\n\t\t\t\toutParts[i] = '0' + part;\n\t\t\t}\n\t\t})\n\t\treturn (`#${outParts.join('')}`);\n\t}\n\n\t/**\n\t * Returns either a positive or negative \n\t * @param {Number} number - number value\n\t * @param {any} positive - value that return when positive\n\t * @param {any} negative - value that return when negative\n\t * @return {any} positive or negative value based on param\n\t */\n\tstatic getSignNum(number, positive, negative) {\n\t\tif (number > 0) {\n\t\t\treturn positive\n\t\t}\n\t\tif (number < 0) {\n\t\t\treturn negative\n\t\t}\n\t\treturn null\n\t}\n\n\t/**\n\t * Returns either ascending or descending value\n\t * @param {Object} a - antd Table sorter param a\n\t * @param {Object} b - antd Table sorter param b\n\t * @param {String} key - object key for compare\n\t * @return {any} a value minus b value\n\t */\n\tstatic antdTableSorter(a, b, key) {\n\t\tif(typeof a[key] === 'number' && typeof b[key] === 'number') {\n\t\t\treturn a[key] - b[key]\n\t\t}\n\n\t\tif(typeof a[key] === 'string' && typeof b[key] === 'string') {\n\t\t\ta = a[key].toLowerCase();\n\t\t\tb = b[key].toLowerCase();\n\t\t\treturn a > b ? -1 : b > a ? 1 : 0;\n\t\t}\n\t\treturn\n\t}\n\n\t/**\n\t * Filter array of object \n\t * @param {Array} list - array of objects that need to filter\n\t * @param {String} key - object key target\n\t * @param {any} value  - value that excluded from filter\n\t * @return {Array} a value minus b value\n\t */\n\tstatic filterArray(list, key, value) {\n\t\tlet data = list\n\t\tif(list) {\n\t\t\tdata = list.filter(item => item[key] === value)\n\t\t}\n\t\treturn data\n\t}\n\n\t/**\n\t * Remove object from array by value\n\t * @param {Array} list - array of objects\n\t * @param {String} key - object key target\n\t * @param {any} value  - target value\n\t * @return {Array} Array that removed target object\n\t */\n\tstatic deleteArrayRow(list, key, value) {\n\t\tlet data = list\n\t\tif(list) {\n\t\t\tdata = list.filter(item => item[key] !== value)\n\t\t}\n\t\treturn data\n\t}\n\n\t/**\n\t * Wild card search on all property of the object\n\t * @param {Number | String} input - any value to search\n\t * @param {Array} list - array for search\n\t * @return {Array} array of object contained keyword\n\t */\n\tstatic wildCardSearch(list, input) {\n\t\tconst searchText = (item) => {\n\t\t\tfor (let key in item) {\n\t\t\t\tif (item[key] == null) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tif (item[key].toString().toUpperCase().indexOf(input.toString().toUpperCase()) !== -1) {\n\t\t\t\t\treturn true;\n\t\t\t\t}\n\t\t\t}\n\t\t};\n\t\tlist = list.filter(value => searchText(value));\n\t\treturn list;\n\t}\n\n\t/**\n\t * Get Breakpoint\n\t * @param {Object} screens - Grid.useBreakpoint() from antd\n\t * @return {Array} array of breakpoint size\n\t */\n\tstatic getBreakPoint(screens) {\n\t\tlet breakpoints = []\n\t\tfor (const key in screens) {\n\t\t\tif (screens.hasOwnProperty(key)) {\n\t\t\t\tconst element = screens[key];\n\t\t\t\tif (element) {\n\t\t\t\t\tbreakpoints.push(key)\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn breakpoints\n\t}\n}\n\nexport default Utils;"]},"metadata":{},"sourceType":"module"}